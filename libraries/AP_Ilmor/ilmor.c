/**
 * @file ilmor.c
 *
 * @brief This source file was generated by cantools version 40.2.3 Fri Jul 11 12:34:39 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <string.h>

#include "ilmor.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int ilmor_unmanned_throttle_control_pack(
    uint8_t *dst_p,
    const struct ilmor_unmanned_throttle_control_t *src_p,
    size_t size)
{
    uint16_t unmanned_p_rpm_demand;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->unmanned_control_key, 0u, 0xffu);
    unmanned_p_rpm_demand = (uint16_t)src_p->unmanned_p_rpm_demand;
    dst_p[1] |= pack_right_shift_u16(unmanned_p_rpm_demand, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(unmanned_p_rpm_demand, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->trim_custom_upper_limit, 0u, 0xffu);

    return (4);
}

int ilmor_unmanned_throttle_control_unpack(
    struct ilmor_unmanned_throttle_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t unmanned_p_rpm_demand;

    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->unmanned_control_key = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    unmanned_p_rpm_demand = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    unmanned_p_rpm_demand |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->unmanned_p_rpm_demand = (int16_t)unmanned_p_rpm_demand;
    dst_p->trim_custom_upper_limit = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    return (0);
}

int ilmor_unmanned_throttle_control_init(struct ilmor_unmanned_throttle_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_unmanned_throttle_control_t));

    return 0;
}

uint8_t ilmor_unmanned_throttle_control_unmanned_control_key_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_unmanned_throttle_control_unmanned_control_key_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_unmanned_throttle_control_unmanned_control_key_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_unmanned_throttle_control_unmanned_p_rpm_demand_encode(float value)
{
    return (int16_t)(value);
}

float ilmor_unmanned_throttle_control_unmanned_p_rpm_demand_decode(int16_t value)
{
    return ((float)value);
}

bool ilmor_unmanned_throttle_control_unmanned_p_rpm_demand_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_unmanned_throttle_control_trim_custom_upper_limit_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_unmanned_throttle_control_trim_custom_upper_limit_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_unmanned_throttle_control_trim_custom_upper_limit_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_7_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_7_t *src_p,
    size_t size)
{
    uint32_t high_precision_battery_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    high_precision_battery_voltage = (uint32_t)src_p->high_precision_battery_voltage;
    dst_p[0] |= pack_right_shift_u32(high_precision_battery_voltage, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(high_precision_battery_voltage, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(high_precision_battery_voltage, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(high_precision_battery_voltage, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_7_unpack(
    struct ilmor_inverter_status_frame_7_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t high_precision_battery_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    high_precision_battery_voltage = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    high_precision_battery_voltage |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    high_precision_battery_voltage |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    high_precision_battery_voltage |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->high_precision_battery_voltage = (int32_t)high_precision_battery_voltage;

    return (0);
}

int ilmor_inverter_status_frame_7_init(struct ilmor_inverter_status_frame_7_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_7_t));

    return 0;
}

int32_t ilmor_inverter_status_frame_7_high_precision_battery_voltage_encode(float value)
{
    return (int32_t)(value / 1e-06f);
}

float ilmor_inverter_status_frame_7_high_precision_battery_voltage_decode(int32_t value)
{
    return ((float)value * 1e-06f);
}

bool ilmor_inverter_status_frame_7_high_precision_battery_voltage_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int ilmor_r3_status_frame_1_pack(
    uint8_t *dst_p,
    const struct ilmor_r3_status_frame_1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->system_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->throttle_lockout, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->safe_start, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->battery_chemistry_type, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->battery_voltage_type, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->battery_capacity, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->battery_capacity, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->server_mode, 0u, 0xffu);

    return (8);
}

int ilmor_r3_status_frame_1_unpack(
    struct ilmor_r3_status_frame_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->system_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->throttle_lockout = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->safe_start = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->battery_chemistry_type = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->battery_voltage_type = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->battery_capacity = unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->battery_capacity |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->server_mode = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_r3_status_frame_1_init(struct ilmor_r3_status_frame_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_r3_status_frame_1_t));

    return 0;
}

uint8_t ilmor_r3_status_frame_1_system_state_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_system_state_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_system_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_1_throttle_lockout_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_throttle_lockout_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_throttle_lockout_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_1_safe_start_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_safe_start_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_safe_start_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_1_battery_chemistry_type_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_battery_chemistry_type_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_battery_chemistry_type_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_1_battery_voltage_type_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_battery_voltage_type_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_battery_voltage_type_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_r3_status_frame_1_battery_capacity_encode(float value)
{
    return (uint16_t)(value / 0.1f);
}

float ilmor_r3_status_frame_1_battery_capacity_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_r3_status_frame_1_battery_capacity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_1_server_mode_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_1_server_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_1_server_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_r3_status_frame_2_pack(
    uint8_t *dst_p,
    const struct ilmor_r3_status_frame_2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->led_hue, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->led_saturation, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->led_value, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->led_rainbow_mode, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->led_pattern, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->trim_demand_request_from_r3, 0u, 0xffu);

    return (8);
}

int ilmor_r3_status_frame_2_unpack(
    struct ilmor_r3_status_frame_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->led_hue = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->led_saturation = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->led_value = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->led_rainbow_mode = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->led_pattern = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->trim_demand_request_from_r3 = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

int ilmor_r3_status_frame_2_init(struct ilmor_r3_status_frame_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_r3_status_frame_2_t));

    return 0;
}

uint8_t ilmor_r3_status_frame_2_led_hue_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_led_hue_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_led_hue_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_2_led_saturation_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_led_saturation_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_led_saturation_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_2_led_value_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_led_value_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_led_value_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_2_led_rainbow_mode_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_led_rainbow_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_led_rainbow_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_2_led_pattern_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_led_pattern_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_led_pattern_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_2_trim_demand_request_from_r3_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_2_trim_demand_request_from_r3_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_2_trim_demand_request_from_r3_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_r3_status_frame_3_pack(
    uint8_t *dst_p,
    const struct ilmor_r3_status_frame_3_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->display_storage_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->calibration_mode, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->logging_mode, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->scaling_soc, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->scaling_soc, 0u, 0xffu);

    return (8);
}

int ilmor_r3_status_frame_3_unpack(
    struct ilmor_r3_status_frame_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->display_storage_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->calibration_mode = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->logging_mode = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->scaling_soc = unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->scaling_soc |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);

    return (0);
}

int ilmor_r3_status_frame_3_init(struct ilmor_r3_status_frame_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_r3_status_frame_3_t));

    return 0;
}

uint8_t ilmor_r3_status_frame_3_display_storage_state_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_3_display_storage_state_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_3_display_storage_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_3_calibration_mode_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_3_calibration_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_3_calibration_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_r3_status_frame_3_logging_mode_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_r3_status_frame_3_logging_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_r3_status_frame_3_logging_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_r3_status_frame_3_scaling_soc_encode(float value)
{
    return (uint16_t)(value / 0.01f);
}

float ilmor_r3_status_frame_3_scaling_soc_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}

bool ilmor_r3_status_frame_3_scaling_soc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int ilmor_password_change_request_pack(
    uint8_t *dst_p,
    const struct ilmor_password_change_request_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_password_change_request_unpack(
    struct ilmor_password_change_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_password_change_request_init(struct ilmor_password_change_request_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_password_change_request_t));

    return 0;
}

int ilmor_password_save_request_pack(
    uint8_t *dst_p,
    const struct ilmor_password_save_request_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_password_save_request_unpack(
    struct ilmor_password_save_request_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_password_save_request_init(struct ilmor_password_save_request_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_password_save_request_t));

    return 0;
}

int ilmor_ds2_pack(
    uint8_t *dst_p,
    const struct ilmor_ds2_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_ds2_unpack(
    struct ilmor_ds2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_ds2_init(struct ilmor_ds2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_ds2_t));

    return 0;
}

int ilmor_ds3_pack(
    uint8_t *dst_p,
    const struct ilmor_ds3_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_ds3_unpack(
    struct ilmor_ds3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_ds3_init(struct ilmor_ds3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_ds3_t));

    return 0;
}

int ilmor_mt1_pack(
    uint8_t *dst_p,
    const struct ilmor_mt1_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_mt1_unpack(
    struct ilmor_mt1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_mt1_init(struct ilmor_mt1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_mt1_t));

    return 0;
}

int ilmor_mt2_pack(
    uint8_t *dst_p,
    const struct ilmor_mt2_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_mt2_unpack(
    struct ilmor_mt2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_mt2_init(struct ilmor_mt2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_mt2_t));

    return 0;
}

int ilmor_icu_status_frame_1_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_1_t *src_p,
    size_t size)
{
    uint8_t input_power;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->trim_position, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->trim_position, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->trim_position_adjusted, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->prop_out_of_water, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->displayed_soc, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->displayed_soc, 0u, 0xffu);
    input_power = (uint8_t)src_p->input_power;
    dst_p[6] |= pack_left_shift_u8(input_power, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_1_unpack(
    struct ilmor_icu_status_frame_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t input_power;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->trim_position = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->trim_position |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->trim_position_adjusted = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->prop_out_of_water = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->displayed_soc = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->displayed_soc |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    input_power = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->input_power = (int8_t)input_power;

    return (0);
}

int ilmor_icu_status_frame_1_init(struct ilmor_icu_status_frame_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_1_t));

    return 0;
}

uint16_t ilmor_icu_status_frame_1_trim_position_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_1_trim_position_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_1_trim_position_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_1_trim_position_adjusted_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_1_trim_position_adjusted_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_1_trim_position_adjusted_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_1_prop_out_of_water_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_1_prop_out_of_water_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_1_prop_out_of_water_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_1_displayed_soc_encode(float value)
{
    return (uint16_t)(value / 0.01f);
}

float ilmor_icu_status_frame_1_displayed_soc_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}

bool ilmor_icu_status_frame_1_displayed_soc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int8_t ilmor_icu_status_frame_1_input_power_encode(float value)
{
    return (int8_t)(value);
}

float ilmor_icu_status_frame_1_input_power_decode(int8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_1_input_power_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_2_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_2_t *src_p,
    size_t size)
{
    uint32_t throttle_demand;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    throttle_demand = (uint32_t)src_p->throttle_demand;
    dst_p[0] |= pack_right_shift_u32(throttle_demand, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_demand, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_demand, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(throttle_demand, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->shift_position, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->software_version_major, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->software_version_minor, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->software_version_patch, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_2_unpack(
    struct ilmor_icu_status_frame_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_demand;

    if (size < 8u) {
        return (-EINVAL);
    }

    throttle_demand = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    throttle_demand |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    throttle_demand |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    throttle_demand |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->throttle_demand = (int32_t)throttle_demand;
    dst_p->shift_position = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->software_version_major = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->software_version_minor = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->software_version_patch = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_2_init(struct ilmor_icu_status_frame_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_2_t));

    return 0;
}

int32_t ilmor_icu_status_frame_2_throttle_demand_encode(float value)
{
    return (int32_t)(value / 0.001f);
}

float ilmor_icu_status_frame_2_throttle_demand_decode(int32_t value)
{
    return ((float)value * 0.001f);
}

bool ilmor_icu_status_frame_2_throttle_demand_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_2_shift_position_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_2_shift_position_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_2_shift_position_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_2_software_version_major_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_2_software_version_major_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_2_software_version_major_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_2_software_version_minor_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_2_software_version_minor_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_2_software_version_minor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_2_software_version_patch_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_2_software_version_patch_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_2_software_version_patch_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_3_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_3_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->throttle_sensor_1_position, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->throttle_sensor_1_position, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->throttle_sensor_2_position, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->throttle_sensor_2_position, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->throttle_sensor_average_position, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->throttle_sensor_average_position, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->five_v_vsense_reference, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->five_v_vsense_reference, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_3_unpack(
    struct ilmor_icu_status_frame_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->throttle_sensor_1_position = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->throttle_sensor_1_position |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->throttle_sensor_2_position = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->throttle_sensor_2_position |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->throttle_sensor_average_position = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->throttle_sensor_average_position |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->five_v_vsense_reference = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->five_v_vsense_reference |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_3_init(struct ilmor_icu_status_frame_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_3_t));

    return 0;
}

uint16_t ilmor_icu_status_frame_3_throttle_sensor_1_position_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_3_throttle_sensor_1_position_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_3_throttle_sensor_1_position_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_3_throttle_sensor_2_position_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_3_throttle_sensor_2_position_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_3_throttle_sensor_2_position_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_3_throttle_sensor_average_position_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_3_throttle_sensor_average_position_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_3_throttle_sensor_average_position_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_3_five_v_vsense_reference_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_3_five_v_vsense_reference_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_3_five_v_vsense_reference_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_4_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->gps_year, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->gps_year, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->gps_month, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->gps_day, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->gps_hour, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->gps_minute, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->gps_second, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->software_version_dev_stage, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_4_unpack(
    struct ilmor_icu_status_frame_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->gps_year = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->gps_year |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->gps_month = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->gps_day = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->gps_hour = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->gps_minute = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->gps_second = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->software_version_dev_stage = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_4_init(struct ilmor_icu_status_frame_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_4_t));

    return 0;
}

uint16_t ilmor_icu_status_frame_4_gps_year_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_icu_status_frame_4_gps_year_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_year_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_gps_month_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_gps_month_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_gps_day_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_gps_day_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_day_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_gps_hour_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_gps_hour_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_hour_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_gps_minute_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_gps_minute_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_minute_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_gps_second_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_gps_second_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_gps_second_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_4_software_version_dev_stage_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_4_software_version_dev_stage_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_4_software_version_dev_stage_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_5_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_5_t *src_p,
    size_t size)
{
    uint32_t gps_latitude;
    uint32_t gps_longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    gps_latitude = (uint32_t)src_p->gps_latitude;
    dst_p[0] |= pack_right_shift_u32(gps_latitude, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_latitude, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_latitude, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(gps_latitude, 0u, 0xffu);
    gps_longitude = (uint32_t)src_p->gps_longitude;
    dst_p[4] |= pack_right_shift_u32(gps_longitude, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(gps_longitude, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(gps_longitude, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(gps_longitude, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_5_unpack(
    struct ilmor_icu_status_frame_5_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_latitude;
    uint32_t gps_longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    gps_latitude = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    gps_latitude |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    gps_latitude |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    gps_latitude |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->gps_latitude = (int32_t)gps_latitude;
    gps_longitude = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    gps_longitude |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    gps_longitude |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    gps_longitude |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);
    dst_p->gps_longitude = (int32_t)gps_longitude;

    return (0);
}

int ilmor_icu_status_frame_5_init(struct ilmor_icu_status_frame_5_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_5_t));

    return 0;
}

int32_t ilmor_icu_status_frame_5_gps_latitude_encode(float value)
{
    return (int32_t)(value / 1e-07f);
}

float ilmor_icu_status_frame_5_gps_latitude_decode(int32_t value)
{
    return ((float)value * 1e-07f);
}

bool ilmor_icu_status_frame_5_gps_latitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t ilmor_icu_status_frame_5_gps_longitude_encode(float value)
{
    return (int32_t)(value / 1e-07f);
}

float ilmor_icu_status_frame_5_gps_longitude_decode(int32_t value)
{
    return ((float)value * 1e-07f);
}

bool ilmor_icu_status_frame_5_gps_longitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_6_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->gps_sog, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->gps_sog, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->gps_cog, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->gps_cog, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->gps_hdop, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->gps_hdop, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->gps_satellite_count, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->software_ver_dev_stage_rev, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_6_unpack(
    struct ilmor_icu_status_frame_6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->gps_sog = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->gps_sog |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->gps_cog = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->gps_cog |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->gps_hdop = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->gps_hdop |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->gps_satellite_count = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->software_ver_dev_stage_rev = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_6_init(struct ilmor_icu_status_frame_6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_6_t));

    return 0;
}

uint16_t ilmor_icu_status_frame_6_gps_sog_encode(float value)
{
    return (uint16_t)(value / 0.01f);
}

float ilmor_icu_status_frame_6_gps_sog_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}

bool ilmor_icu_status_frame_6_gps_sog_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_6_gps_cog_encode(float value)
{
    return (uint16_t)(value / 0.01f);
}

float ilmor_icu_status_frame_6_gps_cog_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}

bool ilmor_icu_status_frame_6_gps_cog_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_6_gps_hdop_encode(float value)
{
    return (uint16_t)(value / 0.001f);
}

float ilmor_icu_status_frame_6_gps_hdop_decode(uint16_t value)
{
    return ((float)value * 0.001f);
}

bool ilmor_icu_status_frame_6_gps_hdop_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_6_gps_satellite_count_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_6_gps_satellite_count_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_6_gps_satellite_count_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_6_software_ver_dev_stage_rev_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_6_software_ver_dev_stage_rev_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_6_software_ver_dev_stage_rev_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_7_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_7_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->filtered_precise_battery_voltage, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->filtered_precise_battery_voltage, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->filtered_precise_battery_voltage, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->filtered_precise_battery_voltage, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->trim_demand_request_from_buttons, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->charging_mode, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->real_soc, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->real_soc, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_7_unpack(
    struct ilmor_icu_status_frame_7_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->filtered_precise_battery_voltage = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->filtered_precise_battery_voltage |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->filtered_precise_battery_voltage |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->filtered_precise_battery_voltage |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->trim_demand_request_from_buttons = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->charging_mode = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->real_soc = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->real_soc |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_7_init(struct ilmor_icu_status_frame_7_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_7_t));

    return 0;
}

uint32_t ilmor_icu_status_frame_7_filtered_precise_battery_voltage_encode(float value)
{
    return (uint32_t)(value / 1e-06f);
}

float ilmor_icu_status_frame_7_filtered_precise_battery_voltage_decode(uint32_t value)
{
    return ((float)value * 1e-06f);
}

bool ilmor_icu_status_frame_7_filtered_precise_battery_voltage_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_7_trim_demand_request_from_buttons_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_7_trim_demand_request_from_buttons_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_7_trim_demand_request_from_buttons_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t ilmor_icu_status_frame_7_charging_mode_encode(float value)
{
    return (uint8_t)(value);
}

float ilmor_icu_status_frame_7_charging_mode_decode(uint8_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_7_charging_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_icu_status_frame_7_real_soc_encode(float value)
{
    return (uint16_t)(value / 0.01f);
}

float ilmor_icu_status_frame_7_real_soc_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}

bool ilmor_icu_status_frame_7_real_soc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int ilmor_icu_status_frame_8_pack(
    uint8_t *dst_p,
    const struct ilmor_icu_status_frame_8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->log_file_size, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->log_file_size, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->log_file_size, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->log_file_size, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->log_size_limit, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->log_size_limit, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->log_size_limit, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->log_size_limit, 0u, 0xffu);

    return (8);
}

int ilmor_icu_status_frame_8_unpack(
    struct ilmor_icu_status_frame_8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->log_file_size = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->log_file_size |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->log_file_size |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->log_file_size |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->log_size_limit = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    dst_p->log_size_limit |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->log_size_limit |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    dst_p->log_size_limit |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_icu_status_frame_8_init(struct ilmor_icu_status_frame_8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_icu_status_frame_8_t));

    return 0;
}

uint32_t ilmor_icu_status_frame_8_log_file_size_encode(float value)
{
    return (uint32_t)(value);
}

float ilmor_icu_status_frame_8_log_file_size_decode(uint32_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_8_log_file_size_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t ilmor_icu_status_frame_8_log_size_limit_encode(float value)
{
    return (uint32_t)(value);
}

float ilmor_icu_status_frame_8_log_size_limit_decode(uint32_t value)
{
    return ((float)value);
}

bool ilmor_icu_status_frame_8_log_size_limit_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int ilmor_password_change_echo_pack(
    uint8_t *dst_p,
    const struct ilmor_password_change_echo_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_password_change_echo_unpack(
    struct ilmor_password_change_echo_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_password_change_echo_init(struct ilmor_password_change_echo_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_password_change_echo_t));

    return 0;
}

int ilmor_password_save_confirmation_pack(
    uint8_t *dst_p,
    const struct ilmor_password_save_confirmation_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int ilmor_password_save_confirmation_unpack(
    struct ilmor_password_save_confirmation_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int ilmor_password_save_confirmation_init(struct ilmor_password_save_confirmation_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_password_save_confirmation_t));

    return 0;
}

int ilmor_inverter_status_frame_1_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_1_t *src_p,
    size_t size)
{
    uint16_t duty_cycle;
    uint16_t motor_current;
    uint32_t e_rpm;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    e_rpm = (uint32_t)src_p->e_rpm;
    dst_p[0] |= pack_right_shift_u32(e_rpm, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(e_rpm, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(e_rpm, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(e_rpm, 0u, 0xffu);
    motor_current = (uint16_t)src_p->motor_current;
    dst_p[4] |= pack_right_shift_u16(motor_current, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(motor_current, 0u, 0xffu);
    duty_cycle = (uint16_t)src_p->duty_cycle;
    dst_p[6] |= pack_right_shift_u16(duty_cycle, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(duty_cycle, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_1_unpack(
    struct ilmor_inverter_status_frame_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t duty_cycle;
    uint16_t motor_current;
    uint32_t e_rpm;

    if (size < 8u) {
        return (-EINVAL);
    }

    e_rpm = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    e_rpm |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    e_rpm |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    e_rpm |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->e_rpm = (int32_t)e_rpm;
    motor_current = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    motor_current |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->motor_current = (int16_t)motor_current;
    duty_cycle = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    duty_cycle |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->duty_cycle = (int16_t)duty_cycle;

    return (0);
}

int ilmor_inverter_status_frame_1_init(struct ilmor_inverter_status_frame_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_1_t));

    return 0;
}

int32_t ilmor_inverter_status_frame_1_e_rpm_encode(float value)
{
    return (int32_t)(value);
}

float ilmor_inverter_status_frame_1_e_rpm_decode(int32_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_1_e_rpm_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_inverter_status_frame_1_motor_current_encode(float value)
{
    return (int16_t)(value / 0.1f);
}

float ilmor_inverter_status_frame_1_motor_current_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_inverter_status_frame_1_motor_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_inverter_status_frame_1_duty_cycle_encode(float value)
{
    return (int16_t)(value / 0.001f);
}

float ilmor_inverter_status_frame_1_duty_cycle_decode(int16_t value)
{
    return ((float)value * 0.001f);
}

bool ilmor_inverter_status_frame_1_duty_cycle_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_2_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->ah_consumed, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->ah_consumed, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->ah_consumed, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->ah_consumed, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->ah_regenerated, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->ah_regenerated, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->ah_regenerated, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->ah_regenerated, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_2_unpack(
    struct ilmor_inverter_status_frame_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ah_consumed = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->ah_consumed |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->ah_consumed |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->ah_consumed |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->ah_regenerated = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    dst_p->ah_regenerated |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->ah_regenerated |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    dst_p->ah_regenerated |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_inverter_status_frame_2_init(struct ilmor_inverter_status_frame_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_2_t));

    return 0;
}

uint32_t ilmor_inverter_status_frame_2_ah_consumed_encode(float value)
{
    return (uint32_t)(value / 0.0001f);
}

float ilmor_inverter_status_frame_2_ah_consumed_decode(uint32_t value)
{
    return ((float)value * 0.0001f);
}

bool ilmor_inverter_status_frame_2_ah_consumed_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t ilmor_inverter_status_frame_2_ah_regenerated_encode(float value)
{
    return (uint32_t)(value / 0.0001f);
}

float ilmor_inverter_status_frame_2_ah_regenerated_decode(uint32_t value)
{
    return ((float)value * 0.0001f);
}

bool ilmor_inverter_status_frame_2_ah_regenerated_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_3_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_3_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->wh_consumed, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->wh_consumed, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->wh_consumed, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->wh_consumed, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->wh_regenerated, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->wh_regenerated, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->wh_regenerated, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->wh_regenerated, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_3_unpack(
    struct ilmor_inverter_status_frame_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->wh_consumed = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->wh_consumed |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->wh_consumed |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->wh_consumed |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->wh_regenerated = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    dst_p->wh_regenerated |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->wh_regenerated |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    dst_p->wh_regenerated |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_inverter_status_frame_3_init(struct ilmor_inverter_status_frame_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_3_t));

    return 0;
}

uint32_t ilmor_inverter_status_frame_3_wh_consumed_encode(float value)
{
    return (uint32_t)(value / 0.0001f);
}

float ilmor_inverter_status_frame_3_wh_consumed_decode(uint32_t value)
{
    return ((float)value * 0.0001f);
}

bool ilmor_inverter_status_frame_3_wh_consumed_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t ilmor_inverter_status_frame_3_wh_regenerated_encode(float value)
{
    return (uint32_t)(value / 0.0001f);
}

float ilmor_inverter_status_frame_3_wh_regenerated_decode(uint32_t value)
{
    return ((float)value * 0.0001f);
}

bool ilmor_inverter_status_frame_3_wh_regenerated_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_4_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_4_t *src_p,
    size_t size)
{
    uint16_t battery_current;
    uint16_t mosfet_temperature;
    uint16_t motor_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    mosfet_temperature = (uint16_t)src_p->mosfet_temperature;
    dst_p[0] |= pack_right_shift_u16(mosfet_temperature, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(mosfet_temperature, 0u, 0xffu);
    motor_temperature = (uint16_t)src_p->motor_temperature;
    dst_p[2] |= pack_right_shift_u16(motor_temperature, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(motor_temperature, 0u, 0xffu);
    battery_current = (uint16_t)src_p->battery_current;
    dst_p[4] |= pack_right_shift_u16(battery_current, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(battery_current, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->motor_pid_position, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->motor_pid_position, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_4_unpack(
    struct ilmor_inverter_status_frame_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t battery_current;
    uint16_t mosfet_temperature;
    uint16_t motor_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    mosfet_temperature = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    mosfet_temperature |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->mosfet_temperature = (int16_t)mosfet_temperature;
    motor_temperature = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    motor_temperature |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->motor_temperature = (int16_t)motor_temperature;
    battery_current = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    battery_current |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->battery_current = (int16_t)battery_current;
    dst_p->motor_pid_position = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->motor_pid_position |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_inverter_status_frame_4_init(struct ilmor_inverter_status_frame_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_4_t));

    return 0;
}

int16_t ilmor_inverter_status_frame_4_mosfet_temperature_encode(float value)
{
    return (int16_t)(value / 0.1f);
}

float ilmor_inverter_status_frame_4_mosfet_temperature_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_inverter_status_frame_4_mosfet_temperature_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_inverter_status_frame_4_motor_temperature_encode(float value)
{
    return (int16_t)(value / 0.1f);
}

float ilmor_inverter_status_frame_4_motor_temperature_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_inverter_status_frame_4_motor_temperature_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_inverter_status_frame_4_battery_current_encode(float value)
{
    return (int16_t)(value / 0.1f);
}

float ilmor_inverter_status_frame_4_battery_current_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_inverter_status_frame_4_battery_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_inverter_status_frame_4_motor_pid_position_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_inverter_status_frame_4_motor_pid_position_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_4_motor_pid_position_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_5_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_5_t *src_p,
    size_t size)
{
    uint16_t low_precision_battery_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->motor_tach, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->motor_tach, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->motor_tach, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->motor_tach, 0u, 0xffu);
    low_precision_battery_voltage = (uint16_t)src_p->low_precision_battery_voltage;
    dst_p[4] |= pack_right_shift_u16(low_precision_battery_voltage, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(low_precision_battery_voltage, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_5_unpack(
    struct ilmor_inverter_status_frame_5_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t low_precision_battery_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->motor_tach = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->motor_tach |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->motor_tach |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->motor_tach |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    low_precision_battery_voltage = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    low_precision_battery_voltage |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->low_precision_battery_voltage = (int16_t)low_precision_battery_voltage;

    return (0);
}

int ilmor_inverter_status_frame_5_init(struct ilmor_inverter_status_frame_5_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_5_t));

    return 0;
}

uint32_t ilmor_inverter_status_frame_5_motor_tach_encode(float value)
{
    return (uint32_t)(value);
}

float ilmor_inverter_status_frame_5_motor_tach_decode(uint32_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_5_motor_tach_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int16_t ilmor_inverter_status_frame_5_low_precision_battery_voltage_encode(float value)
{
    return (int16_t)(value / 0.1f);
}

float ilmor_inverter_status_frame_5_low_precision_battery_voltage_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool ilmor_inverter_status_frame_5_low_precision_battery_voltage_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int ilmor_inverter_status_frame_6_pack(
    uint8_t *dst_p,
    const struct ilmor_inverter_status_frame_6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->adc1_reading, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->adc1_reading, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->adc2_reading, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->adc2_reading, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->adc3_reading, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->adc3_reading, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ppm, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->ppm, 0u, 0xffu);

    return (8);
}

int ilmor_inverter_status_frame_6_unpack(
    struct ilmor_inverter_status_frame_6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adc1_reading = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->adc1_reading |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->adc2_reading = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->adc2_reading |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->adc3_reading = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->adc3_reading |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ppm = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->ppm |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int ilmor_inverter_status_frame_6_init(struct ilmor_inverter_status_frame_6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct ilmor_inverter_status_frame_6_t));

    return 0;
}

uint16_t ilmor_inverter_status_frame_6_adc1_reading_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_inverter_status_frame_6_adc1_reading_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_6_adc1_reading_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_inverter_status_frame_6_adc2_reading_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_inverter_status_frame_6_adc2_reading_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_6_adc2_reading_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_inverter_status_frame_6_adc3_reading_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_inverter_status_frame_6_adc3_reading_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_6_adc3_reading_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t ilmor_inverter_status_frame_6_ppm_encode(float value)
{
    return (uint16_t)(value);
}

float ilmor_inverter_status_frame_6_ppm_decode(uint16_t value)
{
    return ((float)value);
}

bool ilmor_inverter_status_frame_6_ppm_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}
