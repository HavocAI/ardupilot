#!/usr/bin/env python3

import os

def build(bld):
    # Determine the target directory based on the cargo config or hardcoded for now as confirmed by user/config
    # In a robust setup we might sniff this or let cargo decide, but Waf needs to know where to find the artifact.
    # The config.toml in .cargo says "thumbv7em-none-eabihf"
    
    cargo_target = "thumbv7em-none-eabihf"
    release_path = os.path.join(bld.srcnode.abspath(), 'libraries/AP_BoatEKF/target', cargo_target, 'release')
    lib_name = 'libAP_BoatEKF.a'
    
    # Unified task:
    # 1. Runs cargo build (rule)
    # 2. Acts as the usage provider for other libraries (lib/libpath)
    # 3. Runs in 'dynamic_sources' group (implicit or via group='dynamic_sources') to ensure it finishes before linking
    bld(
        name='AP_BoatEKF',
        group='dynamic_sources',
        rule='cd %s/libraries/AP_BoatEKF && cargo build --release' % bld.srcnode.abspath(),
        target=os.path.join(release_path, lib_name),
        # Export usage info for consumers (Rover)
        lib=['AP_BoatEKF'],
        libpath=[release_path],
        always=True,
    )
